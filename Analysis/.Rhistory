}
colSums(check[,4:7])
colSums(outputs[,2:5])
colSums(check[,4:7]) - colSums(outputs[,2:5])
sum(colSums(outputs[,2:5]))
# Ok, still appears to work
outputs <- outputs %>% gather(MOD2HI, SLI, VLI, XLI, key = "inc_bin", value = "infill_aff_pop")
big_table <- left_join(big_table, outputs, by = c("puma" = "puma", "inc_bin" = "inc_bin")) %>%
mutate(infill_aff_hh = infill_aff_pop / NP_avr,
infill_aff_ghg = ghg_per_hh * infill_aff_hh)
infill_aff_ghg_total <- sum(big_table$infill_aff_ghg)
(infill_mkt_rate_ghg_total - infill_aff_ghg_total) / infill_mkt_rate_ghg_total
# Ok, so this is as expected the infill market-rate scenario generates _less_ ghg total
(sum(big_table$infill_aff_hh) - sum(big_table$infill_mkt_rate_hh)) / sum(big_table$infill_mkt_rate_hh) # So there are more households in the affordable priority development scenario.
sum(big_table$infill_aff_pop) == sum(big_table$infill_mkt_rate_pop)
####### There are _large_ variations in the number of units going into each PUMA. I should map this out with proportional symbols
# So that's my allocation of _people_
big_table %>% group_by(inc_bin) %>% summarize(GHGe_mkt = sum(infill_mkt_rate_ghg),
GHGe_aff = sum(infill_aff_ghg),
avr_ghg_per_hh_mkt = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
avr_ghg_per_hh_aff = weighted.mean(ghg_per_hh,infill_aff_hh),
hh_tot_mkt = sum(infill_mkt_rate_hh),
hh_tot_aff = sum(infill_aff_hh))
# So that's mystifying: by prioritizing infill MOD2HI development we end up with this group emitting more.
# Why could this be? It could be that we're allocating people and not households, I doubt that that matters, though
# So it's allocating properly, the average household emissions of XLI households are lower in the infill aff scenario, and this difference is big.
puma_point <- st_centroid(pumashape_raw) %>% right_join(big_table, by = c('PUMACE10' = 'puma'))
ggplot() + geom_sf(aes(fill = region), data = pumashape_joined) +
geom_sf(aes(size = infill_mkt_rate_hh), data = filter(puma_point, inc_bin == "XLI")) + scale_size(range = c(0, 1)) +
ggtitle("Per-HH GHG Footprint, LA: Synthetic Households: ") +
coord_sf(xlim = c(-119, -117),ylim = c(33.5, 34.5)) +
theme_bw()
ggplot() + geom_sf(aes(fill = region), data = pumashape_joined) +
geom_sf(aes(size = infill_mkt_rate_hh), data = filter(puma_point, inc_bin == "XLI")) + scale_size(range = c(0, 6)) +
ggtitle("XLI Households Distribution \nMarket-Rate Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw()
ggplot() + geom_sf(aes(fill = ghg_per_hh, size = 0.5), data = filter(pumashape_joined, inc_bin == "MOD2HI")) +
geom_sf(aes(size = infill_mkt_rate_hh, color = "orange"), data = filter(puma_point, inc_bin == "MOD2HI"), pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Moderate to High Income Households Distribution \nMarket-Rate Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw()
pumashape_regions <- pumashape_joined %>%
group_by(region) %>%
summarise(deve_max = sum(deve_max)) %>%
mutate(region = as.integer(region))
map_eli_mkt_rte <- ggplot() + geom_sf(aes(fill = ghg_per_hh, size = 0.5), data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_mkt_rate_hh, color = "orange"), data = filter(puma_point, inc_bin == "XLI"), pch = 1) + scale_size(range = c(0, 6)) +
# geom_sf(aes(color = region), fill = NA, data = pumashape_regions) + scale_color_continuous(low = "#ff0000", high = "#32ff00") +
ggtitle("Extremely Low Income Households Distribution \nMarket-Rate Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw()
# map_eli_mkt_rte +
#   geom_sf(aes(color = region), fill = NA, data = pumashape_regions) +
#   # ggtitle("Hollow Regions") +
#   # scale_color_gradient(colors = rainbow(7)) +
#   scale_color_continuous(low = "#ff0000", high = "#32ff00")
# plot
# create hollow region plot
ggplot() +
geom_sf(aes(color = region), fill = NA, data = pumashape_regions) +
# ggtitle("Hollow Regions") +
# scale_color_gradient(colors = rainbow(7)) +
scale_color_continuous(low = "#32ff00", high = "#ff0000") +
theme_bw()
# So I could just include an example map and call it day. The allocations appear correct.
# If I want to go nuts I could use mapview and make some nice maps with all the layers, but it'll take a while to learn this
# I think the last bit it to show why the outcome isn't the expected outcome.
# The best way of doing that is to show
# It looks like I could use the split() function to do what I need to do by region, maybe I could
# even do this do deal with the fact I'll need to iterate over my inc_bins
# So if I left join my plce_to_puma with with the mo_plc_to_cnty I can get my county_place_code associated with every place
# Then I can left join adding the five_year_totals. That nearly gives me what I want, but not quite because my whole and unincorporated counties are under-counted. So I then need to take the places that have NAs for the construction counts and consolidate them by county, I'll do this by assigning the last 5 digits of the county_place_code for all unrepoting areas "00000"
# This crosswalk is going to be an absolute bitch. My crosswalk file gives me FIPS that match the FIPS of the CofC. But the FIPS of the unincorporated areas and whole-counties change over time, so I'll need to fix that. That's not too big a problem. The bigger problem is with the crosswalk. I'll need to isolate all the places that are reported in the CofC, then consolidate all the unused places by county. That, I think, is going to be a complicated operation.
# What I need, in the end, is a crosswalk file that takes CofC places and crosswalks then to PUMAs.
# So start with the easy part: I have a lot of places that have FIPS that match the MO crosswalk, those are fine as-is
# Then I'll have a lot of unused places left over. I'll need to crosswalk this subset of places to counties which I can identify with my county_place_codes. This will require a groupby after the crosswalk of places to counties.
# and all along the way I'll need to be sure I end up with the proper number of units in each county and in the whole state.
# So what do I need to do? I need to take my place -> PUMA crosswalk file, apply
# Then I'll allocate all remaining housing in the county to
# So this gives us 2011 to 2015 totals of permitted units and the average population over time and, just for fun, the growth rate in units per person of each place during that period.
# So wer're going to have a little trouble here because while we have a crosswalk that allocates CDPs by fips code to PUMAs, we don't currently have a file that allocates the unincorporated parts of the counties to PUMAs.
# To get around this we could aggregate all of the CDPs that aren't listed in the CofC nto their respective counties and call those the unincorporated areas.
# [Some measure of the income mix of new residents in CA along with a total number (total number matters less) - I could just use PUMS for this too and assume that new housing should be built to roughly match the income profile of the current population]
# Things to ask Jones:
# The emissions factor for electricity - is this at the state level? It appears from the supplementary methodological materials that it is https://docs.google.com/file/d/0B_og3XZlL1dbLXRoSmtaYWVFRWc/edit), but this means that this will be a constatnt for the purposes of this analysis - I guess that's possible. Is there that much variation in carbon intensity between utilities in CA?
# If I want to be slick I could use the Census API: api.census.gov/data/2015/acs5?get=NAME,B01001_001E&for=state:*&key=...
# https://www.census.gov/data/developers/data-sets/acs-5year.html
# Our scenarios will vary by which income households we'll put in each PUMA, but within regions. So each region will have an income mix that will be duplicated in our synthetic population. That synthetic population for the region will then be allocated to the PUMAs by income.
# We'll need to come with income bins too. I'd love to only have 4-person HH, but we can't do that. We'll use four bins: XLI (30% of AMI), VLI (50% of AMI), SLI (80% of AMI), and middle (120% of AMI). Everyone's exactly at each income level. Where do I get the ratios? I could make them mirror the current income mixes. I put PUMAs into regions, I put households into income bins, and I'll have my income mix. I could show this with little pie charts ona map across the state.
# Then the allocation. Each PUMA will need to be able to accomodate all 4 income groups. Then I'll create a function that says "start at the top and work your way down."
# This means I'll also need to crosswalk counties to PUMAs
colnames(pumashape_joined)
View(pumashape_joined)
colnmaes(puma_point)
colnames(puma_point)
pumapoint_aggr <- puma_point %>%
group_by(PUMACE10) %>%
summarise(infill_aff_hh_tot = sum(infill_aff_hh),
infill_mkt_rte_hh_tot = sum(infill_mkt_rate_hh))
ggplot() + geom_sf(aes(size = 0.5), data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_aff_hh_tot, color = "orange"), data = pumapoint_aggr, pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Households Distribution \nAffordable Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw()
ggplot() + geom_sf(data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_aff_hh_tot, color = "orange"), data = pumapoint_aggr, pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Households Distribution \nAffordable Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw()
ggplot() + geom_sf(data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_aff_hh_tot, color = "orange"), data = pumapoint_aggr, pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Households Distribution \nAffordable Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw() + theme(legend.position="none")
ggplot() + geom_sf(aes(size = 0.5), data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_aff_hh_tot, color = "orange"), data = pumapoint_aggr, pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Households Distribution \nAffordable Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw() + theme(legend.position="none")
ggplot() + geom_sf(aes(size = 1), data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_aff_hh_tot, color = "orange"), data = pumapoint_aggr, pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Households Distribution \nAffordable Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw() + theme(legend.position="none")
colnames(pumashape_joined)
ggplot() + geom_sf(aes(fill = deve_max, size = 1), data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_aff_hh_tot, color = "orange"), data = pumapoint_aggr, pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Households Distribution \nAffordable Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw() + theme(legend.position="none")
ggplot() + geom_sf(data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_aff_hh_tot, color = "orange"), data = pumapoint_aggr, pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Households Distribution \nAffordable Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw() + theme(legend.position="none")
ggplot() + geom_sf(data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_mkt_rte_hh_tot, color = "orange"), data = pumapoint_aggr, pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Households Distribution \Market-Rate Infill Scenario") +
ggplot() + geom_sf(data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_mkt_rte_hh_tot, color = "orange"), data = pumapoint_aggr, pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Households Distribution \nMarket-Rate Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw() + theme(legend.position="none")
rm(list=ls())
x <- c("ggmap", "sf", "tidyverse", "foreign", 'forcats', 'censusapi', 'stringr', 'viridis', 'rvest', 'ggplot2', 'knitr') # , "tmap", "rgdal", "rgeos", "maptools", "tidyr"
lapply(x, library, character.only = TRUE) # load all necessary packages
read_cofc <- function(path){
read_csv(url(path), col_names = c('survey_date','state_code','six_digit_id','county_code','census_place_code','fips_place_code','fips_mcd_code', 'pop', 'csa_code', "cbsa_code", "footnote_code", 'central_city', 'zip_code', 'region_code', 'division_code', 'number_of_months_rep', 'place_name', 'x18_bldgs', 'one_unit_units', 'x20_value', 'x21_bldgs', 'two_units_units', 'x23_value', 'x24_bldgs', 'three_and_four_units_units', 'x26_value', 'x27_bldgs', 'five_plus_units_units'), col_types="ccccccciccccccccciiiiiiiiiii_____________",skip=3)[,1:28]
}
cofc <- read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2011a.txt') %>% # read in CofC, join each year and clean
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2012a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2013a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2014a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2015a.txt')) %>%
dplyr::filter(state_code == "06") %>%
select(survey_date,
fips_place_code,
county_code,
place_name,
pop,
one_unit_units,
two_units_units,
three_and_four_units_units,
five_plus_units_units) %>%
mutate(fips_place_code = ifelse(is.na(fips_place_code),"0",fips_place_code)) %>% # apparently FIPS conventions for unincorporated areas and whole-county places changed over time, so sometimes it's NA, sometimes it's 00000 and sometimes it's 99990.
mutate(county_code = paste0(county_code,"00000")) %>%
mutate(permitted_units_annual = one_unit_units + two_units_units + three_and_four_units_units + five_plus_units_units) %>%
mutate(county_place_code = paste0("0",as.character(as.integer(county_code) + as.integer(fips_place_code) + 600000000))) %>%
group_by(place_name) # I'm making county-place codes for whole-counties and the unincorporated areas of counties by adding the county code and then choosing either 00000 or 99990 to represent the whole or remainder of the county. At the moment I've chosen 00000 by using the min function below
cofc <- read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2011a.txt') %>% # read in CofC, join each year and clean
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2012a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2013a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2014a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2015a.txt')) %>%
dplyr::filter(state_code == "06") %>%
select(survey_date,
fips_place_code,
county_code,
place_name,
pop,
one_unit_units,
two_units_units,
three_and_four_units_units,
five_plus_units_units) %>%
mutate(fips_place_code = ifelse(is.na(fips_place_code),"0",fips_place_code)) %>% # apparently FIPS conventions for unincorporated areas and whole-county places changed over time, so sometimes it's NA, sometimes it's 00000 and sometimes it's 99990.
mutate(county_code = paste0(county_code,"00000")) %>%
mutate(permitted_units_annual = one_unit_units + two_units_units + three_and_four_units_units + five_plus_units_units) %>%
mutate(county_place_code = paste0("0",as.character(as.integer(county_code) + as.integer(fips_place_code) + 600000000))) %>%
group_by(place_name) # I'm making county-place codes for whole-counties and the unincorporated areas of counties by adding the county code and then choosing either 00000 or 99990 to represent the whole or remainder of the county. At the moment I've chosen 00000 by using the min function below
five_year_totals <- summarize(cofc,permitted_units = sum(permitted_units_annual),
average_population = mean(pop, na.rm = TRUE),
county_place_code = min(county_place_code))
rm(list=ls())
x <- c("ggmap", "sf", "tidyverse", "foreign", 'forcats', 'censusapi', 'stringr', 'viridis', 'rvest', 'ggplot2', 'knitr') # , "tmap", "rgdal", "rgeos", "maptools", "tidyr"
lapply(x, library, character.only = TRUE) # load all necessary packages
read_cofc <- function(path){
read_csv(url(path), col_names = c('survey_date','state_code','six_digit_id','county_code','census_place_code','fips_place_code','fips_mcd_code', 'pop', 'csa_code', "cbsa_code", "footnote_code", 'central_city', 'zip_code', 'region_code', 'division_code', 'number_of_months_rep', 'place_name', 'x18_bldgs', 'one_unit_units', 'x20_value', 'x21_bldgs', 'two_units_units', 'x23_value', 'x24_bldgs', 'three_and_four_units_units', 'x26_value', 'x27_bldgs', 'five_plus_units_units'), col_types="ccccccciccccccccciiiiiiiiiii_____________",skip=3)[,1:28]
}
cofc <- read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2011a.txt') %>% # read in CofC, join each year and clean
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2012a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2013a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2014a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2015a.txt')) %>%
dplyr::filter(state_code == "06") %>%
select(survey_date,
fips_place_code,
county_code,
place_name,
pop,
one_unit_units,
two_units_units,
three_and_four_units_units,
five_plus_units_units) %>%
mutate(fips_place_code = ifelse(is.na(fips_place_code),"0",fips_place_code)) %>% # apparently FIPS conventions for unincorporated areas and whole-county places changed over time, so sometimes it's NA, sometimes it's 00000 and sometimes it's 99990.
mutate(county_code = paste0(county_code,"00000")) %>%
mutate(permitted_units_annual = one_unit_units + two_units_units + three_and_four_units_units + five_plus_units_units) %>%
mutate(county_place_code = paste0("0",as.character(as.integer(county_code) + as.integer(fips_place_code) + 600000000))) %>%
group_by(place_name) # I'm making county-place codes for whole-counties and the unincorporated areas of counties by adding the county code and then choosing either 00000 or 99990 to represent the whole or remainder of the county. At the moment I've chosen 00000 by using the min function below
five_year_totals <- summarize(cofc,permitted_units = sum(permitted_units_annual),
average_population = mean(pop, na.rm = TRUE),
county_place_code = min(county_place_code))
# Now I'll need to consolidate the small counties that are bundled up in single PUMAs
consolidator <- function(x){
ifelse(x %in% consol_list$input, consol_list$output[match(x, consol_list$input)], x)
}
# I'll consolidate the Nevada-ish counties (Alpine, Amador, Calaveras, Inyo, Mariposa, Mono, Tuolumne) under Alpine, the Northern counties (Del Norte, Lassen, Modoc, Plumas, Siskiyou) under Del Norte, Nevada under Sierra, Yuba under Sutter, (Colusa, Glenn, Tehama & Trinity) under Tehama, Lake under Mendocino, San Benito under monterey
consol_list <- tibble(input = c('0600500000', '0600900000', '0602700000', '0604300000', '0605100000', '0610900000', '0603500000', '0604900000', '0606300000', '0609300000', '0609100000', '0611500000', '0601100000', '0602100000', '0610500000', '0603300000', '0606900000'), output = c('0600300000', '0600300000', '0600300000', '0600300000', '0600300000', '0600300000', '0601500000', '0601500000', '0601500000', '0601500000', '0605700000', '0610100000', '0610300000', '0610300000', '0610300000', '0604500000', '0605300000'))
five_year_totals <- mutate(five_year_totals, county_place_code = consolidator(county_place_code)) %>%
group_by(county_place_code) %>%
summarize(permitted_units = sum(permitted_units))
namer <- function(x,cp_code,fips){
ifelse((x == "" | is.na(x)), cp_code, paste0(x,fips))
}
# Ok, so this crosswalk shows us there's weirdness with places and counties. Some places have one name, but different FIPS for the counties they're in (e.g. Bear Valley) some places span multiple counties, but have only one FIPS (e.g. Aromas). There are only 5 places like Aromas, where one FIPs straddles multiple counties. The places with separate FIPS should be just fine, I can join them using my place_county_codes. The places like Aromas will give me a problem, because I'll be creating a new place_county code that won't match with anything but associated with a place_name that will match. This opens the possibility that a place will either be doubled or dropped. I'll need to match by place-name or place_fips. Given that there are only five problem places, maybe I can just put them in one county or another and not have a big problem. So I'll need to do two things here: consolidate the Aromas manually and then append the FIPS to the placenames to separate out the Bear Valleys
# Thi
mo_plc_to_cnty <- read_csv("../Data/CrosswalkPlace2Countyhaus.csv", col_names=c('FIPS_state', 'placefp14', 'county', 'State_Postal_Code', 'cntyname', 'placefp', 'placenm', 'Place_Name_2014', 'Total_HUs_2010', "placefp14_to_county_alloc_factor"), skip = 1) %>%
dplyr::filter(FIPS_state == "06")
split_fips <- drop_na(tibble(Place_Name_2014 = unique(mo_plc_to_cnty$Place_Name_2014[duplicated(mo_plc_to_cnty$placefp14)]),
county = c('06053','06037','06057','06003','06017',NA)))
fips_consolidator <- function(place_name, county){
ifelse(place_name %in% split_fips$Place_Name_2014, split_fips$county[match(place_name, split_fips$Place_Name_2014)], county)
}
mo_plc_to_cnty <- read_csv("../Data/CrosswalkPlace2Countyhaus.csv", col_names=c('FIPS_state', 'placefp14', 'county', 'State_Postal_Code', 'cntyname', 'placefp', 'placenm', 'Place_Name_2014', 'Total_HUs_2010', "placefp14_to_county_alloc_factor"), skip = 1) %>%
dplyr::filter(FIPS_state == "06") %>%
mutate(placefp14 = str_replace(placefp14, "99999", "00000")) %>%
mutate(county = fips_consolidator(Place_Name_2014,county)) %>%
mutate(county_place_code = paste0(county,placefp14),
Total_HUs_2010 = as.integer(Total_HUs_2010),
placefp14_to_county_alloc_factor = as.double(placefp14_to_county_alloc_factor)) %>%
mutate(county_place_code = consolidator(county_place_code)) %>% # Ok, I'll need to consolidate some whole-counties here to make the subsequent join work.
group_by(county_place_code,placefp14) %>%
summarize(Total_HUs_2010 = sum(Total_HUs_2010),
Place_Name_2014 = min(Place_Name_2014)) %>%
mutate(Place_Name_2014 = namer(Place_Name_2014, county_place_code, placefp14))
sum(mo_plc_to_cnty$Total_HUs_2010) == 13680081 # Ok, per the 2010 Census there were 13,680,081 units of housing in CA
mo_plc_to_cnty[duplicated(mo_plc_to_cnty$county_place_code),]
length(mo_plc_to_cnty$Place_Name_2014) - length(unique(mo_plc_to_cnty$Place_Name_2014))
knitr::opts_chunk$set(echo = FALSE, message=FALSE, warning = FALSE)
rm(list=ls())
x <- c("ggmap", "sf", "tidyverse", "foreign", 'forcats', 'censusapi', 'stringr', 'viridis', 'rvest', 'ggplot2', 'knitr') # , "tmap", "rgdal", "rgeos", "maptools", "tidyr"
lapply(x, library, character.only = TRUE) # load all necessary packages
rm(list=ls())
x <- c("ggmap", "sf", "tidyverse", "foreign", 'forcats', 'censusapi', 'stringr', 'viridis', 'rvest', 'ggplot2', 'knitr') # , "tmap", "rgdal", "rgeos", "maptools", "tidyr"
lapply(x, library, character.only = TRUE) # load all necessary packages
read_cofc <- function(path){
read_csv(url(path), col_names = c('survey_date','state_code','six_digit_id','county_code','census_place_code','fips_place_code','fips_mcd_code', 'pop', 'csa_code', "cbsa_code", "footnote_code", 'central_city', 'zip_code', 'region_code', 'division_code', 'number_of_months_rep', 'place_name', 'x18_bldgs', 'one_unit_units', 'x20_value', 'x21_bldgs', 'two_units_units', 'x23_value', 'x24_bldgs', 'three_and_four_units_units', 'x26_value', 'x27_bldgs', 'five_plus_units_units'), col_types="ccccccciccccccccciiiiiiiiiii_____________",skip=3)[,1:28]
}
cofc <- read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2011a.txt') %>% # read in CofC, join each year and clean
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2012a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2013a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2014a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2015a.txt')) %>%
dplyr::filter(state_code == "06") %>%
select(survey_date,
fips_place_code,
county_code,
place_name,
pop,
one_unit_units,
two_units_units,
three_and_four_units_units,
five_plus_units_units) %>%
mutate(fips_place_code = ifelse(is.na(fips_place_code),"0",fips_place_code)) %>% # apparently FIPS conventions for unincorporated areas and whole-county places changed over time, so sometimes it's NA, sometimes it's 00000 and sometimes it's 99990.
mutate(county_code = paste0(county_code,"00000")) %>%
mutate(permitted_units_annual = one_unit_units + two_units_units + three_and_four_units_units + five_plus_units_units) %>%
mutate(county_place_code = paste0("0",as.character(as.integer(county_code) + as.integer(fips_place_code) + 600000000))) %>%
group_by(place_name) # I'm making county-place codes for whole-counties and the unincorporated areas of counties by adding the county code and then choosing either 00000 or 99990 to represent the whole or remainder of the county. At the moment I've chosen 00000 by using the min function below
cofc <- read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2011a.txt') %>% # read in CofC, join each year and clean
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2012a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2013a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2014a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2015a.txt')) %>%
dplyr::filter(state_code == "06") %>%
select(survey_date,
fips_place_code,
county_code,
place_name,
pop,
one_unit_units,
two_units_units,
three_and_four_units_units,
five_plus_units_units) %>%
mutate(fips_place_code = ifelse(is.na(fips_place_code),"0",fips_place_code)) %>% # apparently FIPS conventions for unincorporated areas and whole-county places changed over time, so sometimes it's NA, sometimes it's 00000 and sometimes it's 99990.
mutate(county_code = paste0(county_code,"00000")) %>%
mutate(permitted_units_annual = one_unit_units + two_units_units + three_and_four_units_units + five_plus_units_units) %>%
mutate(county_place_code = paste0("0",as.character(as.integer(county_code) + as.integer(fips_place_code) + 600000000))) %>%
group_by(place_name) # I'm making county-place codes for whole-counties and the unincorporated areas of counties by adding the county code and then choosing either 00000 or 99990 to represent the whole or remainder of the county. At the moment I've chosen 00000 by using the min function below
five_year_totals <- summarize(cofc,permitted_units = sum(permitted_units_annual),
average_population = mean(pop, na.rm = TRUE),
county_place_code = min(county_place_code))
rm(list=ls())
x <- c("ggmap", "sf", "tidyverse", "foreign", 'forcats', 'censusapi', 'stringr', 'viridis', 'rvest', 'ggplot2', 'knitr') # , "tmap", "rgdal", "rgeos", "maptools", "tidyr"
lapply(x, library, character.only = TRUE) # load all necessary packages
?readr
rm(list=ls())
x <- c('readr',"ggmap", "sf", "tidyverse", "foreign", 'forcats', 'censusapi', 'stringr', 'viridis', 'rvest', 'ggplot2', 'knitr') # , "tmap", "rgdal", "rgeos", "maptools", "tidyr"
lapply(x, library, character.only = TRUE) # load all necessary packages
rm(list=ls())
x <- c('readr',"ggmap", "sf", "tidyverse", "foreign", 'forcats', 'censusapi', 'stringr', 'viridis', 'rvest', 'ggplot2', 'knitr') # , "tmap", "rgdal", "rgeos", "maptools", "tidyr"
lapply(x, library, character.only = TRUE) # load all necessary packages
?guess_encoding
rm(list=ls())
x <- c("ggmap", "sf", "tidyverse", "foreign", 'forcats', 'censusapi', 'stringr', 'viridis', 'ggplot2', 'knitr') # , "tmap", "rgdal", "rgeos", "maptools", "tidyr", 'rvest'
lapply(x, library, character.only = TRUE) # load all necessary packages
read_cofc <- function(path){
read_csv(url(path), col_names = c('survey_date','state_code','six_digit_id','county_code','census_place_code','fips_place_code','fips_mcd_code', 'pop', 'csa_code', "cbsa_code", "footnote_code", 'central_city', 'zip_code', 'region_code', 'division_code', 'number_of_months_rep', 'place_name', 'x18_bldgs', 'one_unit_units', 'x20_value', 'x21_bldgs', 'two_units_units', 'x23_value', 'x24_bldgs', 'three_and_four_units_units', 'x26_value', 'x27_bldgs', 'five_plus_units_units'), col_types="ccccccciccccccccciiiiiiiiiii_____________",skip=3)[,1:28]
}
cofc <- read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2011a.txt') %>% # read in CofC, join each year and clean
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2012a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2013a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2014a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2015a.txt')) %>%
dplyr::filter(state_code == "06") %>%
select(survey_date,
fips_place_code,
county_code,
place_name,
pop,
one_unit_units,
two_units_units,
three_and_four_units_units,
five_plus_units_units) %>%
mutate(fips_place_code = ifelse(is.na(fips_place_code),"0",fips_place_code)) %>% # apparently FIPS conventions for unincorporated areas and whole-county places changed over time, so sometimes it's NA, sometimes it's 00000 and sometimes it's 99990.
mutate(county_code = paste0(county_code,"00000")) %>%
mutate(permitted_units_annual = one_unit_units + two_units_units + three_and_four_units_units + five_plus_units_units) %>%
mutate(county_place_code = paste0("0",as.character(as.integer(county_code) + as.integer(fips_place_code) + 600000000))) %>%
group_by(place_name) # I'm making county-place codes for whole-counties and the unincorporated areas of counties by adding the county code and then choosing either 00000 or 99990 to represent the whole or remainder of the county. At the moment I've chosen 00000 by using the min function below
five_year_totals <- summarize(cofc,permitted_units = sum(permitted_units_annual),
average_population = mean(pop, na.rm = TRUE),
county_place_code = min(county_place_code))
consolidator <- function(x){
ifelse(x %in% consol_list$input, consol_list$output[match(x, consol_list$input)], x)
}
consol_list <- tibble(input = c('0600500000', '0600900000', '0602700000', '0604300000', '0605100000', '0610900000', '0603500000', '0604900000', '0606300000', '0609300000', '0609100000', '0611500000', '0601100000', '0602100000', '0610500000', '0603300000', '0606900000'), output = c('0600300000', '0600300000', '0600300000', '0600300000', '0600300000', '0600300000', '0601500000', '0601500000', '0601500000', '0601500000', '0605700000', '0610100000', '0610300000', '0610300000', '0610300000', '0604500000', '0605300000'))
five_year_totals <- mutate(five_year_totals, county_place_code = consolidator(county_place_code)) %>%
group_by(county_place_code) %>%
summarize(permitted_units = sum(permitted_units))
namer <- function(x,cp_code,fips){
ifelse((x == "" | is.na(x)), cp_code, paste0(x,fips))
}
mo_plc_to_cnty <- read_csv("../Data/CrosswalkPlace2Countyhaus.csv", col_names=c('FIPS_state', 'placefp14', 'county', 'State_Postal_Code', 'cntyname', 'placefp', 'placenm', 'Place_Name_2014', 'Total_HUs_2010', "placefp14_to_county_alloc_factor"), skip = 1) %>%
dplyr::filter(FIPS_state == "06")
split_fips <- drop_na(tibble(Place_Name_2014 = unique(mo_plc_to_cnty$Place_Name_2014[duplicated(mo_plc_to_cnty$placefp14)]),
county = c('06053','06037','06057','06003','06017',NA)))
fips_consolidator <- function(place_name, county){
ifelse(place_name %in% split_fips$Place_Name_2014, split_fips$county[match(place_name, split_fips$Place_Name_2014)], county)
}
mo_plc_to_cnty <- read_csv("../Data/CrosswalkPlace2Countyhaus.csv", col_names=c('FIPS_state', 'placefp14', 'county', 'State_Postal_Code', 'cntyname', 'placefp', 'placenm', 'Place_Name_2014', 'Total_HUs_2010', "placefp14_to_county_alloc_factor"), skip = 1) %>%
dplyr::filter(FIPS_state == "06") %>%
mutate(placefp14 = str_replace(placefp14, "99999", "00000")) %>%
mutate(county = fips_consolidator(Place_Name_2014,county)) %>%
mutate(county_place_code = paste0(county,placefp14),
Total_HUs_2010 = as.integer(Total_HUs_2010),
placefp14_to_county_alloc_factor = as.double(placefp14_to_county_alloc_factor)) %>%
mutate(county_place_code = consolidator(county_place_code)) %>% # Ok, I'll need to consolidate some whole-counties here to make the subsequent join work.
group_by(county_place_code,placefp14) %>%
summarize(Total_HUs_2010 = sum(Total_HUs_2010),
Place_Name_2014 = min(Place_Name_2014)) %>%
mutate(Place_Name_2014 = namer(Place_Name_2014, county_place_code, placefp14))
sum(mo_plc_to_cnty$Total_HUs_2010) == 13680081 # Ok, per the 2010 Census there were 13,680,081 units of housing in CA
mo_plc_to_cnty[duplicated(mo_plc_to_cnty$county_place_code),]
length(mo_plc_to_cnty$Place_Name_2014) - length(unique(mo_plc_to_cnty$Place_Name_2014))
mo_plc_to_cnty$Place_Name_2014[1]
n_distinct(mo_plc_to_cnty$Place_Name_2014[1])
n_distinct(mo_plc_to_cnty$Place_Name_2014)
rm(list=ls())
x <- c("ggmap", "sf", "tidyverse", "foreign", 'forcats', 'censusapi', 'stringr', 'viridis', 'ggplot2', 'knitr') # , "tmap", "rgdal", "rgeos", "maptools", "tidyr", 'rvest'
lapply(x, library, character.only = TRUE) # load all necessary packages
read_cofc <- function(path){
read_csv(url(path), col_names = c('survey_date','state_code','six_digit_id','county_code','census_place_code','fips_place_code','fips_mcd_code', 'pop', 'csa_code', "cbsa_code", "footnote_code", 'central_city', 'zip_code', 'region_code', 'division_code', 'number_of_months_rep', 'place_name', 'x18_bldgs', 'one_unit_units', 'x20_value', 'x21_bldgs', 'two_units_units', 'x23_value', 'x24_bldgs', 'three_and_four_units_units', 'x26_value', 'x27_bldgs', 'five_plus_units_units'), col_types="ccccccciccccccccciiiiiiiiiii_____________",skip=3)[,1:28]
}
cofc <- read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2011a.txt') %>% # read in CofC, join each year and clean
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2012a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2013a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2014a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2015a.txt')) %>%
dplyr::filter(state_code == "06") %>%
select(survey_date,
fips_place_code,
county_code,
place_name,
pop,
one_unit_units,
two_units_units,
three_and_four_units_units,
five_plus_units_units) %>%
mutate(fips_place_code = ifelse(is.na(fips_place_code),"0",fips_place_code)) %>% # apparently FIPS conventions for unincorporated areas and whole-county places changed over time, so sometimes it's NA, sometimes it's 00000 and sometimes it's 99990.
mutate(county_code = paste0(county_code,"00000")) %>%
mutate(permitted_units_annual = one_unit_units + two_units_units + three_and_four_units_units + five_plus_units_units) %>%
mutate(county_place_code = paste0("0",as.character(as.integer(county_code) + as.integer(fips_place_code) + 600000000))) %>%
group_by(place_name) # I'm making county-place codes for whole-counties and the unincorporated areas of counties by adding the county code and then choosing either 00000 or 99990 to represent the whole or remainder of the county. At the moment I've chosen 00000 by using the min function below
cofc <- read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2011a.txt') %>% # read in CofC, join each year and clean
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2012a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2013a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2014a.txt')) %>%
rbind(read_cofc('https://www2.census.gov/econ/bps/Place/West%20Region/we2015a.txt')) %>%
dplyr::filter(state_code == "06") %>%
select(survey_date,
fips_place_code,
county_code,
place_name,
pop,
one_unit_units,
two_units_units,
three_and_four_units_units,
five_plus_units_units) %>%
mutate(fips_place_code = ifelse(is.na(fips_place_code),"0",fips_place_code)) %>% # apparently FIPS conventions for unincorporated areas and whole-county places changed over time, so sometimes it's NA, sometimes it's 00000 and sometimes it's 99990.
mutate(county_code = paste0(county_code,"00000")) %>%
mutate(permitted_units_annual = one_unit_units + two_units_units + three_and_four_units_units + five_plus_units_units) %>%
mutate(county_place_code = paste0("0",as.character(as.integer(county_code) + as.integer(fips_place_code) + 600000000))) %>%
group_by(place_name) # I'm making county-place codes for whole-counties and the unincorporated areas of counties by adding the county code and then choosing either 00000 or 99990 to represent the whole or remainder of the county. At the moment I've chosen 00000 by using the min function below
five_year_totals <- summarize(cofc,permitted_units = sum(permitted_units_annual),
average_population = mean(pop, na.rm = TRUE),
county_place_code = min(county_place_code))
consolidator <- function(x){
ifelse(x %in% consol_list$input, consol_list$output[match(x, consol_list$input)], x)
}
consol_list <- tibble(input = c('0600500000', '0600900000', '0602700000', '0604300000', '0605100000', '0610900000', '0603500000', '0604900000', '0606300000', '0609300000', '0609100000', '0611500000', '0601100000', '0602100000', '0610500000', '0603300000', '0606900000'), output = c('0600300000', '0600300000', '0600300000', '0600300000', '0600300000', '0600300000', '0601500000', '0601500000', '0601500000', '0601500000', '0605700000', '0610100000', '0610300000', '0610300000', '0610300000', '0604500000', '0605300000'))
five_year_totals <- mutate(five_year_totals, county_place_code = consolidator(county_place_code)) %>%
group_by(county_place_code) %>%
summarize(permitted_units = sum(permitted_units))
namer <- function(x,cp_code,fips){
ifelse((x == "" | is.na(x)), cp_code, paste0(x,fips))
}
mo_plc_to_cnty <- read_csv("../Data/CrosswalkPlace2Countyhaus.csv", col_names=c('FIPS_state', 'placefp14', 'county', 'State_Postal_Code', 'cntyname', 'placefp', 'placenm', 'Place_Name_2014', 'Total_HUs_2010', "placefp14_to_county_alloc_factor"), skip = 1) %>%
dplyr::filter(FIPS_state == "06")
split_fips <- drop_na(tibble(Place_Name_2014 = unique(mo_plc_to_cnty$Place_Name_2014[duplicated(mo_plc_to_cnty$placefp14)]),
county = c('06053','06037','06057','06003','06017',NA)))
fips_consolidator <- function(place_name, county){
ifelse(place_name %in% split_fips$Place_Name_2014, split_fips$county[match(place_name, split_fips$Place_Name_2014)], county)
}
mo_plc_to_cnty <- read_csv("../Data/CrosswalkPlace2Countyhaus.csv", col_names=c('FIPS_state', 'placefp14', 'county', 'State_Postal_Code', 'cntyname', 'placefp', 'placenm', 'Place_Name_2014', 'Total_HUs_2010', "placefp14_to_county_alloc_factor"), skip = 1) %>%
dplyr::filter(FIPS_state == "06") %>%
mutate(placefp14 = str_replace(placefp14, "99999", "00000")) %>%
mutate(county = fips_consolidator(Place_Name_2014,county)) %>%
mutate(county_place_code = paste0(county,placefp14),
Total_HUs_2010 = as.integer(Total_HUs_2010),
placefp14_to_county_alloc_factor = as.double(placefp14_to_county_alloc_factor)) %>%
mutate(county_place_code = consolidator(county_place_code)) %>% # Ok, I'll need to consolidate some whole-counties here to make the subsequent join work.
group_by(county_place_code,placefp14) %>%
summarize(Total_HUs_2010 = sum(Total_HUs_2010),
Place_Name_2014 = min(Place_Name_2014)) %>%
mutate(Place_Name_2014 = namer(Place_Name_2014, county_place_code, placefp14))
sum(mo_plc_to_cnty$Total_HUs_2010) == 13680081 # Ok, per the 2010 Census there were 13,680,081 units of housing in CA
mo_plc_to_cnty[duplicated(mo_plc_to_cnty$county_place_code),]
length(mo_plc_to_cnty$Place_Name_2014) - length(unique(mo_plc_to_cnty$Place_Name_2014))
mo_plc_to_puma <- read_csv("../Data/CrosswalkPlace2PUMAhaus.csv", col_names=c('FIPS_state', 'placefp14', 'puma12', 'State_Postal_Code', 'placefp', 'placenm', 'Place_Name_2014', 'PUMA12_Name', 'Total_HUs_2010', "placefp14_to_puma12_alloc_factor"), skip = 2) %>%
mutate(placefp14 = str_replace(placefp14, "99999", "00000"))
unincorp_list <- tibble(puma = mo_plc_to_puma[mo_plc_to_puma$placefp14 == "00000",]$PUMA12_Name, cnty = c(1,1,1,1,3,7,7,103,13,13,13,13,13,13,13,13,13,15,17,19,19,19,19,19,19,19,23,25,29,29,29,29,29,31,45,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,39,41,41,47,47,53,53,53,55,57,59,59,59,59,59,59,59,59,59,59,59,61,61,61,65,65,65,65,65,65,65,65,65,65,65,65,65,65,67,67,67,67,67,71,71,71,71,71,71,71,71,71,71,71,71,71,71,73,73,73,73,73,73,73,73,73,73,73,73,73,73,73,77,77,77,77,79,79,81,81,81,81,81,81,83,83,83,85,85,85,85,85,85,85,85,85,85,87,87,89,95,95,95,97,97,97,99,99,99,99,101,107,107,107,111,111,111,111,111,111,113)) %>%
mutate(county_place_code = paste0("0",(cnty*100000)+600000000))
unincorp_ider <- function(place_fip, puma_name, place_name){
ifelse(place_fip == "00000", unincorp_list$county_place_code[match(puma_name, unincorp_list$puma)], paste0(place_name,place_fip))
}
unincorp_consolidator <- function(units, county, cp_code){
ifelse(is.na(units), paste0(county,"00000"), cp_code)
}
mo_plc_to_puma <-  mutate(mo_plc_to_puma, Place_Name_2014 = unincorp_ider(placefp14, PUMA12_Name, Place_Name_2014)) %>%
left_join(mo_plc_to_cnty, by = "Place_Name_2014") %>%
mutate(county = str_sub(county_place_code, 1, 5)) %>%
full_join(five_year_totals, by = "county_place_code") %>%
mutate(county_place_code = unincorp_consolidator(permitted_units, county, county_place_code)) %>%
mutate(county_place_code = consolidator(county_place_code)) %>%
group_by(county_place_code, puma12) %>%# Now I'm going to consolidate the unincorporated areas of each county
summarize(PUMA12_Name = max(PUMA12_Name),
Total_HUs_2010 = sum(Total_HUs_2010.x)) %>%
full_join(five_year_totals, by = "county_place_code")
county_place_code_HU_totals <- group_by(mo_plc_to_puma, county_place_code) %>%
summarize(Total_HUs_2010 = sum(Total_HUs_2010, na.rm = TRUE))
factor_adjuster <- function(cpc, hu){
hu / county_place_code_HU_totals$Total_HUs_2010[match(cpc, county_place_code_HU_totals$county_place_code)]
}
mo_plc_to_puma <- mutate(mo_plc_to_puma, placefp14_to_puma12_alloc_factor = factor_adjuster(county_place_code, Total_HUs_2010),
permitted_units_adj = placefp14_to_puma12_alloc_factor * permitted_units,
county = str_sub(county_place_code, 1, 5))
sum(mo_plc_to_puma$Total_HUs_2010, na.rm = TRUE) == 13680081
sum(five_year_totals$permitted_units) == sum(mo_plc_to_puma$permitted_units_adj, na.rm = TRUE)
consolidator_short <- function(x){
ifelse(x %in% consol_list_short$input, consol_list_short$output[match(x, consol_list_short$input)], x)
}
consol_list_short <- consol_list %>% map(function(x) str_sub(x, 1, 5)) %>% as.tibble # I'll need to adjust the list of county-place codes for unincorporated areas of small counties down to county codes for this dataset
puma_table <-  mutate(mo_plc_to_puma, county = consolidator_short(county)) %>%
group_by(puma12, county) %>% # I need to be careful here because some PUMAs go across multiple counties when they're created as aaggregates of places. I'll need to consolidate here.
summarize(Total_HUs_2010 = sum(Total_HUs_2010, na.rm = TRUE),
permitted_units = sum(permitted_units_adj, na.rm = TRUE))
puma_table[duplicated(puma_table$puma12, fromLast = TRUE) | duplicated(puma_table$puma12, fromLast = FALSE),]
puma_table <- puma_table %>% mutate(county = ifelse(puma12 == '05908', '06059', ifelse(puma12 == '06103', '06061', county))) %>%
group_by(puma12, county) %>%
summarize(Total_HUs_2010 = sum(Total_HUs_2010, na.rm = TRUE),
permitted_units = sum(permitted_units, na.rm = TRUE))
sum(puma_table$Total_HUs_2010, na.rm = TRUE) == 13680081
sum(five_year_totals$permitted_units) == sum(puma_table$permitted_units, na.rm = TRUE)
