full_join(five_year_totals, by = "county_place_code") %>%
mutate(county_place_code = unincorp_consolidator(permitted_units, county, county_place_code)) %>%
mutate(county_place_code = consolidator(county_place_code)) %>%
group_by(county_place_code, puma12) %>%# Now I'm going to consolidate the unincorporated areas of each county
summarize(PUMA12_Name = max(PUMA12_Name),
Total_HUs_2010 = sum(Total_HUs_2010.x)) %>%
full_join(five_year_totals, by = "county_place_code")
county_place_code_HU_totals <- group_by(mo_plc_to_puma, county_place_code) %>%
summarize(Total_HUs_2010 = sum(Total_HUs_2010, na.rm = TRUE))
factor_adjuster <- function(cpc, hu){
hu / county_place_code_HU_totals$Total_HUs_2010[match(cpc, county_place_code_HU_totals$county_place_code)]
}
mo_plc_to_puma <- mutate(mo_plc_to_puma, placefp14_to_puma12_alloc_factor = factor_adjuster(county_place_code, Total_HUs_2010),
permitted_units_adj = placefp14_to_puma12_alloc_factor * permitted_units,
county = str_sub(county_place_code, 1, 5))
sum(mo_plc_to_puma$Total_HUs_2010, na.rm = TRUE) == 13680081
sum(five_year_totals$permitted_units) == sum(mo_plc_to_puma$permitted_units_adj, na.rm = TRUE)
consolidator_short <- function(x){
ifelse(x %in% consol_list_short$input, consol_list_short$output[match(x, consol_list_short$input)], x)
}
consol_list_short <- consol_list %>% map(function(x) str_sub(x, 1, 5)) %>% as.tibble # I'll need to adjust the list of county-place codes for unincorporated areas of small counties down to county codes for this dataset
puma_table <-  mutate(mo_plc_to_puma, county = consolidator_short(county)) %>%
group_by(puma12, county) %>% # I need to be careful here because some PUMAs go across multiple counties when they're created as aaggregates of places. I'll need to consolidate here.
summarize(Total_HUs_2010 = sum(Total_HUs_2010, na.rm = TRUE),
permitted_units = sum(permitted_units_adj, na.rm = TRUE))
puma_table[duplicated(puma_table$puma12, fromLast = TRUE) | duplicated(puma_table$puma12, fromLast = FALSE),]
puma_table <- puma_table %>% mutate(county = ifelse(puma12 == '05908', '06059', ifelse(puma12 == '06103', '06061', county))) %>%
group_by(puma12, county) %>%
summarize(Total_HUs_2010 = sum(Total_HUs_2010, na.rm = TRUE),
permitted_units = sum(permitted_units, na.rm = TRUE))
sum(puma_table$Total_HUs_2010, na.rm = TRUE) == 13680081
sum(five_year_totals$permitted_units) == sum(puma_table$permitted_units, na.rm = TRUE)
censuskey <- 'f8b8ef413394e43d536ae3829d873bf0c246b1ba'
pop2015 <- getCensus(name="acs5",
vintage=2015,
key=censuskey,
vars=c("NAME", "B01001_001E"),
region="public use microdata area",
regionin="state:06")
pop2015 <- getCensus(name="acs5",
vintage=2015,
key=censuskey,
vars=c("NAME", "B01001_001E"),
region="public use microdata area",
regionin="state:06")
puma_table <- left_join(ungroup(puma_table), pop2015, by = c('puma12' = 'public.use.microdata.area')) %>%
transmute(puma12 = puma12,
county = county,
Total_HUs_2010 = Total_HUs_2010,
permitted_units = permitted_units,
population = B01001_001E)
countyshape <- st_read(dsn = "../Data/Shapefiles/california_county_clipped_58.shp")
url <- "https://www2.census.gov/geo/tiger/GENZ2016/shp/cb_2016_06_puma10_500k.zip"
downloaddir <- "../Data/Shapefiles"
destname <- "puma.zip"
download.file(url, destname)
download.file(url, destname)
unzip(destname, exdir=downloaddir, junkpaths=TRUE)
pumashape_raw <- st_read(dsn = "../Data/Shapefiles/cb_2016_06_puma10_500k.shp")
?unzip
pumashape_raw$ALAND10 <- as.numeric(as.character(pumashape_raw$ALAND10))
puma_table <- left_join(puma_table, pumashape_raw, by = c("puma12" = "PUMACE10")) %>%
transmute(puma12 = puma12,
PUMA12_Name = NAME10,
county = county,
Total_HUs_2010 = Total_HUs_2010,
permitted_units = permitted_units,
population = population,
pop_density = population / (ALAND10 / 4046.86))
sum(puma_table$Total_HUs_2010, na.rm = TRUE) == 13680081
sum(five_year_totals$permitted_units) == sum(puma_table$permitted_units, na.rm = TRUE)
hud_mfis <- read_csv('../Data/HUDamis/CleanHUD2015mfi.csv') #col_types="cccciiiiiiii")
hud_mfis_bins <- group_by(hud_mfis,Inc_Limit) %>%
summarize(count = n())
pop_growth <- read_csv("../data/DOFpopGrowth.csv")
total_pop_growth <- sum(pop_growth$Growth_2015_2020)
county_mfi_binned <- mutate(hud_mfis,
FIPSSTCO = paste0("0",as.character(6000 + County_FIPS))) %>%
left_join(pop_growth, by = "County") %>%
transmute(county_name = County,
mfi = Inc_Limit,
county = FIPSSTCO,
pop_growth = Growth_2015_2020) %>%
mutate(county = consolidator_short(county),
growth_for_weight = ifelse(pop_growth < 0, NA, pop_growth))
total_pop_growth == sum(county_mfi_binned$pop_growth)
puma_inc_denoms <- group_by(county_mfi_binned, county) %>%
summarize(total_growth = sum(growth_for_weight, na.rm = TRUE))
mfi_weighter <- function(growth, county){
ifelse(growth < 0, NA, puma_inc_denoms$total_growth[match(county, puma_inc_denoms$county)])
}
county_mfi_growth <- mutate(county_mfi_binned, weight = pop_growth / mfi_weighter(pop_growth,county)) %>%
mutate(mfi_adjusted = mfi * weight) %>%
ungroup() %>%
group_by(county) %>%
summarize(mfi = round(sum(mfi_adjusted, na.rm = TRUE), -2),
county_pop_growth = sum(pop_growth))
county_mfi_growth <- mutate(county_mfi_growth, mfi = ifelse(mfi < 59600, 59600, mfi))
sum(pop_growth$Growth_2015_2020) == sum(county_mfi_growth$county_pop_growth)
group_by(county_mfi_growth,mfi) %>% summarize(count = n())
puma_table <- left_join(puma_table, county_mfi_growth, by = 'county') %>%
drop_na()
puma_mfi_quantiles <- quantile(puma_table$mfi, probs = seq(0, 1, (1/5)))
puma_table <-   mutate(puma_table, region = ifelse(mfi < puma_mfi_quantiles[[2]], 5,
ifelse(mfi < puma_mfi_quantiles[[3]], 4,
ifelse(mfi < puma_mfi_quantiles[[4]], 3,
ifelse(mfi < puma_mfi_quantiles[[5]], 2, 1)))))
puma_table %>%  group_by(region) %>% summarize(pumas = n())
county_weighting <- left_join(county_mfi_growth, puma_table, by = 'county') %>%
group_by(county) %>%
summarize(county_pop_growth = max(county_pop_growth.y),
mfi = max(mfi.x),
region = max(region)) %>%
mutate(growth_for_weights = ifelse(county_pop_growth < 0, NA, county_pop_growth))
regional_growth_denom <- group_by(county_weighting, region) %>%
summarize(regional_growth_weight = sum(growth_for_weights, na.rm = TRUE))
mfi_weighter_2 <- function(region){
regional_growth_denom$regional_growth_weight[match(region, regional_growth_denom$region)]
} # Need to come up with a weighted mfi by region.
county_weighting <- mutate(county_weighting, weighted_mfi = mfi * (growth_for_weights / mfi_weighter_2(region))) %>%
group_by(region) %>%
summarize(mfi_adjusted = round(sum(weighted_mfi, na.rm = TRUE), -2))
region_table <- mutate(pop_growth, county_fips = paste0("06", county_fips),
county = consolidator_short(county_fips)) %>%
left_join(puma_table, by = 'county') %>%
select(county_fips, Growth_2015_2020, region) %>%
distinct() %>%
group_by(region) %>%
summarize(pop_growth = sum(Growth_2015_2020)) %>%
left_join(county_weighting, by = 'region')
regional_share_denom <- group_by(puma_table, region) %>%
summarize(permitted_units_regional = sum(permitted_units))
deve_weighter <- function(deve, region){
regional_share_denom$permitted_units_regional[match(region, regional_share_denom$region)]
}
puma_table <- mutate(puma_table, regional_deve_share = permitted_units / deve_weighter(permitted_units, region))
sum(puma_table$regional_deve_share)
puma_table <- left_join(puma_table, region_table, by = 'region') %>%
transmute(puma12 = puma12,
PUMA12_Name = PUMA12_Name,
county = county,
region = region,
Total_HUs_2010 = Total_HUs_2010,
pop_density = pop_density,
mfi_adjusted = mfi_adjusted,
regional_deve_share = regional_deve_share)
hh_size_adj <- tibble(hh_size = 1:20,
size_factor = c(0.70, 0.80, 0.90, seq(from = 1, to = (1+(.08*(20-4))), by = .08)))
x_walk_puma <- read_csv('../Data/CrosswalkPUMA002PUMA10haus.csv')
acs <- read_csv('../Data/csv_hca/ss15hca.csv', col_types= paste0("____cc___iii",paste0(rep('_',19),collapse=""),"i",paste0(rep('_',10),collapse=""),"c_i", paste0(rep('_',9),collapse=""), "i", paste0(rep('_',(209-55)),collapse=""), collapse = "")) %>%
left_join(x_walk_puma, by = c('PUMA00' = 'puma2k')) %>% # Crosswalk all the 2000 PUMAs from 2011 to 2010 PUMAs
mutate(afact = as.double(afact),
WGTP_10 = WGTP * afact,
WGTP_adj = ifelse(is.na(WGTP_10), WGTP, WGTP_10),
puma = ifelse(PUMA10 == "-0009", puma12, PUMA10),
HINCP_adj = HINCP * (ADJINC/1000000)) %>%
transmute(puma = puma,
WGTP = WGTP_adj,
NP = NP,
RMSP = RMSP,
VACS = VACS,
VEH = VEH,
HINCP = HINCP_adj)
(sum(acs$WGTP) - 13680081) / 13680081 # So the ACS numbers are off from the factfinder numbers by 1%
hh_inc_binner <- function(mfi, hh_size, inc){
ifelse(inc < (hh_size_adj$size_factor[match(hh_size, hh_size_adj$hh_size)] * mfi * .3), "XLI",
ifelse(inc < (hh_size_adj$size_factor[match(hh_size, hh_size_adj$hh_size)] * mfi * .5), "VLI", ifelse(inc < (hh_size_adj$size_factor[match(hh_size, hh_size_adj$hh_size)] * mfi * .8), "SLI", "MOD2HI")))
}
hh_ami_ider <- function(mfi, hh_size, inc){
inc / (hh_size_adj$size_factor[match(hh_size, hh_size_adj$hh_size)] * mfi)
}
acs <- left_join(acs, puma_table, by = c('puma' = 'puma12')) %>%
filter(is.na(VACS)) %>%
transmute(puma = puma,
WGTP = WGTP,
NP = NP,
RMSP = RMSP,
VACS = VACS,
VEH = VEH,
HINCP = HINCP,
region = region,
mfi_adjusted = mfi_adjusted,
inc_bin = hh_inc_binner(mfi_adjusted, NP, HINCP),
ami_level = hh_ami_ider(mfi_adjusted, NP, HINCP))
region_table_1 <- group_by(acs, region, inc_bin) %>%
summarize(inc = sum(WGTP)) %>%
ungroup() %>%
drop_na() %>%
spread(key = inc_bin, value = inc) %>%
transmute(region = region,
XLI_pct = XLI / (XLI + SLI + MOD2HI + VLI),
VLI_pct = VLI / (XLI + SLI + MOD2HI + VLI),
SLI_pct = SLI / (XLI + SLI + MOD2HI + VLI),
MOD2HI_pct = MOD2HI / (XLI + SLI + MOD2HI + VLI))
region_table <- left_join(region_table,region_table_1, by = 'region')
synth_hh <- group_by(acs, puma, inc_bin) %>%
summarize(VEH_avr = sum(WGTP * VEH) / sum(WGTP),
NP_avr = sum(WGTP * NP) / sum(WGTP),
RMSP_avr = sum(WGTP * RMSP) / sum(WGTP),
HINCP_avr = sum(WGTP * HINCP) / sum(WGTP),
counts = n())%>% # Now I need to come up with the characteristics of my synthetic households. To do this I need to come up with the weighted average characteristics of every household in each income bin.
drop_na() %>%
left_join(dplyr::select(puma_table, puma12, pop_density), by = c('puma' = 'puma12')) %>%
mutate(log_pop_density = log10(pop_density),
ln_NP_avr = log(NP_avr))
jones_zips <- read_csv("../Data/bgdata-carbon-footprint-CA.csv") %>%
transmute(ZCTA = ZCTA,
`Total Carbon Footprint` = `Total Carbon Footprint`,
POPDENSITY = (PEOPLE / LANDAREA) * 4046.86,
lnHHSIZE = log(HHSIZE),
INCOME2013 = INCOME2013,
VEHICLES = VEHICLES,
ROOMS = ROOMS) %>%
drop_na() %>%
mutate(logPOPDENSITY = log10(POPDENSITY))
ghg_lm <- lm(`Total Carbon Footprint` ~ logPOPDENSITY + lnHHSIZE + INCOME2013 + VEHICLES + ROOMS, data = jones_zips)
summary(ghg_lm)
synth_hh <- mutate(synth_hh, ghg_per_hh = ghg_lm$coefficients['(Intercept)']+ (ghg_lm$coefficients['VEHICLES'] * VEH_avr) + (ghg_lm$coefficients['INCOME2013'] * HINCP_avr) + (ghg_lm$coefficients['ROOMS'] * RMSP_avr) +
(ghg_lm$coefficients['lnHHSIZE'] * ln_NP_avr) + (ghg_lm$coefficients['logPOPDENSITY'] * log_pop_density),
ghg_per_person = ghg_per_hh / NP_avr) # Create the GHG footprint for every kind of synthetic household.
big_table <- left_join(synth_hh, select(puma_table, puma12, PUMA12_Name, region, regional_deve_share), by = c('puma' = 'puma12')) %>%
left_join(region_table, by = 'region') %>%
mutate(deve_max = (regional_deve_share * pop_growth) / NP_avr,
region = as.factor(region))
pumashape_joined <- left_join(pumashape_raw, big_table, by = c('PUMACE10' = 'puma'))
region_map <- ggplot(pumashape_joined) + geom_sf(aes(fill = region))
income_footprint_mapper <- function(shp, inc){
filter(shp, inc_bin == inc) %>%
ggplot() + geom_sf(aes(fill = ghg_per_hh)) +
scale_fill_viridis("Per-HH GHG Footprint") +
ggtitle(paste0("Per-HH GHG Footprint: Synthetic Households: ", inc)) +
theme_bw()
}
for(i in c("XLI", "VLI", "SLI", "MOD2HI")){
nam <- paste("map", i, sep = "_")
assign(nam, income_footprint_mapper(pumashape_joined, i))
}
income_footprint_la_mapper <- function(shp, inc){
filter(shp, inc_bin == inc) %>%
ggplot() + geom_sf(aes(fill = ghg_per_hh)) +
scale_fill_viridis("Per-HH GHG Footprint") +
ggtitle(paste0("Per-HH GHG Footprint, LA: Synthetic Households: ", inc)) +
coord_sf(xlim = c(-119, -117),ylim = c(33.5, 34.5)) +
theme_bw()
}
for(i in c("XLI", "VLI", "SLI", "MOD2HI")){
nam <- paste("map_LA", i, sep = "_")
assign(nam, income_footprint_la_mapper(pumashape_joined, i))
}
income_footprint_sf_mapper <- function(shp, inc){
filter(shp, inc_bin == inc) %>%
ggplot() + geom_sf(aes(fill = ghg_per_hh)) +
scale_fill_viridis("Per-HH GHG Footprint") +
ggtitle(paste0("Per-HH GHG Footprint \nSan Francisco Bay Area \nSynthetic Households: ", inc)) +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw()
}
for(i in c("XLI", "VLI", "SLI", "MOD2HI")){
nam <- paste("map_SF", i, sep = "_")
assign(nam, income_footprint_sf_mapper(pumashape_joined, i))
}
inc_levels <- unique(big_table$inc_bin)
n_regions <- unique(big_table$region)
puma_blanks <- rep(0, n_distinct(big_table$puma))
outputs <- tibble(puma = unique(big_table$puma), MOD2HI = puma_blanks, SLI = puma_blanks, VLI = puma_blanks, XLI = puma_blanks)
for (h in (1:length(n_regions))){
temp_region <- big_table[big_table$region == n_regions[h],]# for each region we create a slice of the dataframe
for (i in 1:length(inc_levels)){ # First we iterate over the income bins
temp <- temp_region[temp_region$inc_bin == inc_levels[i],] # for each income bin we create a slice of the dataframe
#assign(paste0('output', inc_levels[i]), vector("double", nrow(temp))) # for each income bin we create an output vector, identified by the bin name
#assign(paste0('pumas', inc_levels[i]), vector("double", nrow(temp))) # ... and an associated PUMA indicator
remaining_pop <- unique(region_table$pop_growth[match(temp$region, region_table$region)]) * unique(region_table[, grepl(inc_levels[i], colnames(region_table))][[1]][match(temp$region, region_table$region)])
temp <- dplyr::arrange(temp, ghg_per_person)
for(j in seq(to = nrow(temp))) { # So now I've got a problem in that I'm trying to call the specific objects that I've just named, I'm ok overwriting temp and remaining pop with each itreation bby I need to preserve my output vectors
max_pop_capacity <- temp$deve_max[j] * temp$NP_avr[j]
# hh_remaining <- remaining_pop / temp$NP_avr[j] # I've decided to just allocate population
already_allocated <- sum(outputs[match(temp$puma[j], outputs$puma), 2:5])
outputs[[match(temp$puma[j], outputs$puma), i + 1]] <- round(ifelse(remaining_pop > (max_pop_capacity - already_allocated), (max_pop_capacity - already_allocated), remaining_pop), 0) # So I can't use "get" here because I can't assign to an object I get
# get(paste0('pumas', inc_levels[i]))[[j]] <- temp$puma[[j]]
remaining_pop <- round(remaining_pop - ifelse(remaining_pop > (max_pop_capacity - already_allocated), (max_pop_capacity - already_allocated), remaining_pop), 0)
}
}
}
check <- region_table %>%
mutate_at(.vars = vars(XLI_pct, VLI_pct, SLI_pct, MOD2HI_pct),
.funs = funs(pop_growth * .))
colSums(check[,4:7])
rev(colSums(outputs[,2:5]))
colSums(check[,4:7]) - rev(colSums(outputs[,2:5]))
sum(rev(colSums(outputs[,2:5])))
outputs <- outputs %>% gather(MOD2HI, SLI, VLI, XLI, key = "inc_bin", value = "infill_mkt_rate_pop")
big_table <- left_join(big_table, outputs, by = c("puma" = "puma", "inc_bin" = "inc_bin")) %>%
mutate(infill_mkt_rate_hh = infill_mkt_rate_pop / NP_avr,
infill_mkt_rate_ghg = ghg_per_hh * infill_mkt_rate_hh)
infill_mkt_rate_ghg_total <-  sum(big_table$infill_mkt_rate_ghg)
inc_levels <- rev(unique(big_table$inc_bin))
outputs <- tibble(puma = unique(big_table$puma), XLI = puma_blanks, VLI = puma_blanks, SLI = puma_blanks, MOD2HI = puma_blanks)
for (h in (1:length(n_regions))){
temp_region <- big_table[big_table$region == n_regions[h],]# for each region we create a slice of the dataframe
for (i in 1:length(inc_levels)){ # First we iterate over the income bins
temp <- temp_region[temp_region$inc_bin == inc_levels[i],] # for each income bin we create a slice of the dataframe
#assign(paste0('output', inc_levels[i]), vector("double", nrow(temp))) # for each income bin we create an output vector, identified by the bin name
#assign(paste0('pumas', inc_levels[i]), vector("double", nrow(temp))) # ... and an associated PUMA indicator
remaining_pop <- unique(region_table$pop_growth[match(temp$region, region_table$region)]) * unique(region_table[, grepl(inc_levels[i], colnames(region_table))][[1]][match(temp$region, region_table$region)])
temp <- dplyr::arrange(temp, ghg_per_person)
for(j in seq(to = nrow(temp))) { # So now I've got a problem in that I'm trying to call the specific objects that I've just named, I'm ok overwriting temp and remaining pop with each itreation bby I need to preserve my output vectors
max_pop_capacity <- temp$deve_max[j] * temp$NP_avr[j]
# hh_remaining <- remaining_pop / temp$NP_avr[j] # I've decided to just allocate population
already_allocated <- sum(outputs[match(temp$puma[j], outputs$puma), 2:5])
outputs[[match(temp$puma[j], outputs$puma), i + 1]] <- round(ifelse(remaining_pop > (max_pop_capacity - already_allocated), (max_pop_capacity - already_allocated), remaining_pop), 0) # So I can't use "get" here because I can't assign to an object I get
# get(paste0('pumas', inc_levels[i]))[[j]] <- temp$puma[[j]]
remaining_pop <- round(remaining_pop - ifelse(remaining_pop > (max_pop_capacity - already_allocated), (max_pop_capacity - already_allocated), remaining_pop), 0)
}
}
}
colSums(check[,4:7])
colSums(outputs[,2:5])
colSums(check[,4:7]) - colSums(outputs[,2:5])
sum(colSums(outputs[,2:5]))
outputs <- outputs %>% gather(MOD2HI, SLI, VLI, XLI, key = "inc_bin", value = "infill_aff_pop")
big_table <- left_join(big_table, outputs, by = c("puma" = "puma", "inc_bin" = "inc_bin")) %>%
mutate(infill_aff_hh = infill_aff_pop / NP_avr,
infill_aff_ghg = ghg_per_hh * infill_aff_hh)
infill_aff_ghg_total <- sum(big_table$infill_aff_ghg)
(infill_mkt_rate_ghg_total - infill_aff_ghg_total) / infill_mkt_rate_ghg_total
(sum(big_table$infill_aff_hh) - sum(big_table$infill_mkt_rate_hh)) / sum(big_table$infill_mkt_rate_hh) # So there are more households in the affordable priority development scenario.
sum(big_table$infill_aff_pop) == sum(big_table$infill_mkt_rate_pop)
big_table %>% group_by(inc_bin) %>% summarize(GHGe_mkt = sum(infill_mkt_rate_ghg),
GHGe_aff = sum(infill_aff_ghg),
avr_ghg_per_hh_mkt = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
avr_ghg_per_hh_aff = weighted.mean(ghg_per_hh,infill_aff_hh),
hh_tot_mkt = sum(infill_mkt_rate_hh),
hh_tot_aff = sum(infill_aff_hh))
puma_point <- st_centroid(pumashape_raw) %>% right_join(big_table, by = c('PUMACE10' = 'puma'))
ggplot() + geom_sf(aes(fill = region), data = pumashape_joined) +
geom_sf(aes(size = infill_mkt_rate_hh), data = filter(puma_point, inc_bin == "XLI")) + scale_size(range = c(0, 1)) +
ggtitle("Per-HH GHG Footprint, LA: Synthetic Households: ") +
coord_sf(xlim = c(-119, -117),ylim = c(33.5, 34.5)) +
theme_bw()
ggplot() + geom_sf(aes(fill = region), data = pumashape_joined) +
geom_sf(aes(size = infill_mkt_rate_hh), data = filter(puma_point, inc_bin == "XLI")) + scale_size(range = c(0, 1)) +
ggtitle("Per-HH GHG Footprint, LA: Synthetic Households: ") +
coord_sf(xlim = c(-119, -117),ylim = c(33.5, 34.5)) +
theme_bw()
ggplot() + geom_sf(aes(fill = region), data = pumashape_joined) +
geom_sf(aes(size = infill_mkt_rate_hh), data = filter(puma_point, inc_bin == "XLI")) + scale_size(range = c(0, 6)) +
ggtitle("XLI Households Distribution \nMarket-Rate Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw()
ggplot() + geom_sf(aes(fill = ghg_per_hh, size = 0.5), data = filter(pumashape_joined, inc_bin == "MOD2HI")) +
geom_sf(aes(size = infill_mkt_rate_hh, color = "orange"), data = filter(puma_point, inc_bin == "MOD2HI"), pch = 1) + scale_size(range = c(0, 6)) +
ggtitle("Moderate to High Income Households Distribution \nMarket-Rate Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw()
pumashape_regions <- pumashape_joined %>%
group_by(region) %>%
summarise(deve_max = sum(deve_max)) %>%
mutate(region = as.integer(region))
map_eli_mkt_rte <- ggplot() + geom_sf(aes(fill = ghg_per_hh, size = 0.5), data = filter(pumashape_joined, inc_bin == "XLI")) +
geom_sf(aes(size = infill_mkt_rate_hh, color = "orange"), data = filter(puma_point, inc_bin == "XLI"), pch = 1) + scale_size(range = c(0, 6)) +
# geom_sf(aes(color = region), fill = NA, data = pumashape_regions) + scale_color_continuous(low = "#ff0000", high = "#32ff00") +
ggtitle("Extremely Low Income Households Distribution \nMarket-Rate Infill Scenario") +
coord_sf(xlim = c(-123, -121),ylim = c(37, 38.5)) +
theme_bw()
ggplot() +
geom_sf(aes(color = region), fill = NA, data = pumashape_regions) +
# ggtitle("Hollow Regions") +
# scale_color_gradient(colors = rainbow(7)) +
scale_color_continuous(low = "#32ff00", high = "#ff0000") +
theme_bw()
big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
mutate(`Income Category` = inc_bin) %>%
rbind(c("Total",as.list(unlist(t(colSums(.[,-1])))[1:4]),as.list(unlist(t(colSums(.[,-1])))[5:6]))) %>%
kable(format = 'markdown', format.args = list(big.mark = ','), caption = "Summary Results")
big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
mutate(`Income Category` = inc_bin) %>%
rbind(c("Total",as.list(unlist(t(colSums(.[,-1])))[1:4]),as.list(unlist(t(colMeans(.[,-1])))[5:6]))) %>%
kable(format = 'markdown', format.args = list(big.mark = ','), caption = "Summary Results")
big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
mutate(`Income Category` = inc_bin)
fat <- big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
mutate(`Income Category` = inc_bin)
fat
c("Total",as.list(unlist(t(colSums(fat[,-1])))[1:4]),as.list(unlist(t(colMeans(fat[,-1])))[5:6]))
c("Total",as.list(unlist(t(colSums(fat[,-1])))[1:4]))
colSums(fat[,-1])
fat[,-1]
big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
select(`Income Category` = inc_bin) %>%
rbind(c("Total",as.list(unlist(t(colSums(.[,-1])))[1:4]),as.list(unlist(t(colMeans(.[,-1])))[5:6]))) %>%
kable(format = 'markdown', format.args = list(big.mark = ','), caption = "Summary Results")
library(knitr)
big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
select(`Income Category` = inc_bin) %>%
rbind(c("Total",as.list(unlist(t(colSums(.[,-1])))[1:4]),as.list(unlist(t(colMeans(.[,-1])))[5:6]))) %>%
kable(format = 'markdown', format.args = list(big.mark = ','), caption = "Summary Results")
big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
select(`Income Category` = inc_bin, 2:6) %>%
rbind(c("Total",as.list(unlist(t(colSums(.[,-1])))[1:4]),as.list(unlist(t(colMeans(.[,-1])))[5:6]))) %>%
kable(format = 'markdown', format.args = list(big.mark = ','), caption = "Summary Results")
big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
select(`Income Category` = inc_bin, 2:6) %>%
rbind(c("Total",as.list(unlist(t(colSums(.[,-1])))[1:4]),as.list(unlist(t(colMeans(.[,-1])))[5:6])))
big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
select(`Income Category` = inc_bin, 2:7) %>%
rbind(c("Total",as.list(unlist(t(colSums(.[,-1])))[1:4]),as.list(unlist(t(colMeans(.[,-1])))[5:6])))
big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
select(`Income Category` = inc_bin, 2:6) %>%
rbind(c("Total",as.list(unlist(t(colSums(.[,-1])))[1:4]),as.list(unlist(t(colMeans(.[,-1])))[5:6])))
View(big_table %>% ungroup() %>% group_by(inc_bin) %>% summarize(`Households: Market Infill (1,000s)` = sum(infill_mkt_rate_hh) / 1000,
`Households: Affordable Infill (1,000s)` = sum(infill_aff_hh) / 1000,
`Emissions: Market Infill (1,000s)` = sum(infill_mkt_rate_ghg) / 1000,
`Emissions: Affordable Infill (1,000s)`  = sum(infill_aff_ghg) / 1000,
`Per-HH Emissions: Market Infill` = weighted.mean(ghg_per_hh, infill_mkt_rate_hh),
`Per-HH Emissions: Affordable Infill` = weighted.mean(ghg_per_hh,infill_aff_hh)) %>%
mutate_at(.vars = vars(`Households: Market Infill (1,000s)`, `Households: Affordable Infill (1,000s)`, `Emissions: Market Infill (1,000s)`, `Emissions: Affordable Infill (1,000s)`),
.funs = funs(round(. ,0))) %>%
mutate_at(.vars = vars(`Per-HH Emissions: Market Infill`, `Per-HH Emissions: Affordable Infill`),
.funs = funs(round(. ,1))) %>%
select(`Income Category` = inc_bin, 2:7) %>%
rbind(c("Total",as.list(unlist(t(colSums(.[,-1])))[1:4]),as.list(unlist(t(colMeans(.[,-1])))[5:6]))))
colnames(pumashape_joined)
